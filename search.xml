<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序无限生成 form ID]]></title>
    <url>%2F2018%2F02%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%A0%E9%99%90%E5%88%B6%E7%94%9F%E6%88%90formId%2F</url>
    <content type="text"><![CDATA[请注意：如无特殊情况不建议使用该方法生成form ID为用户推送消息，可能会对用户造成骚扰。从用户角度出发建议明确告知用户消息推送机制，按照正常流程为用户提供消息推送服务 微信小程序模板消息推送需要配合form ID进行使用，这种做法可以防止服务方对用户产生消息骚扰。而这种设定带来便利的同时也对服务端为用户提供更好的服务产生了阻碍。在用户提交一次表单后发送多条消息提醒的环境中，服务方无法保证拿到足够数量的form ID来为用户下发消息提醒。这时需要使用变通的方法获取足够数量的 from ID。 微信小程序模板消息（官方说明） 微信小程序基于微信的通知渠道，为开发者提供了可以高效触达用户的模板消息能力，以便实现服务的闭环并提供更佳的体验。 下发条件说明 支付当用户在小程序内完成过支付行为，可允许开发者向用户在 7 天内推送有限条数的模板消息（1 次支付可下发 3 条，多次支付下发条数独立，互相不影响） 提交表单当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在 7 天内推送有限条数的模板消息（1 次提交表单可下发 1 条，多次提交下发条数独立，相互不影响） 单条 form ID 生成方法根据微信小程序官方文档说明，当用户主动提交一个report-submit属性为 true 的表单时，即可产生一个from ID。 无限生成示例根据单条生成规则，可在用户常用按钮上包裹 form 表单并将表单的report-submit属性设置为 true ，这样即可在用户点击按钮时提交一个隐藏的表单来生成一个 form ID。服务端可将该 form ID 收集起来为之后的消息推送做准备。 上图为自定义的底部 tab 导航按钮，该区域为用户常用点击区域。现将该区域改造为 form ID 生成点。 使用form元素将每个按钮包裹成为一个表单。并为button元素设置form-type=&quot;submit&quot;来提交该表单。设置button元素为hidden，使用与之绑定的label元素美化样式即可。 1234567891011&lt;!-- home.wxml --&gt;&lt;view class='tabBar'&gt; &lt;form bindsubmit='getForm' report-submit='true' data-url='&#123;&#123;item.url&#125;&#125;' wx:for="&#123;&#123;tabBar.list&#125;&#125;" wx:key="&#123;&#123;index&#125;&#125;"&gt; &lt;label for='tab&#123;&#123;index&#125;&#125;'&gt; &lt;image src='&#123;&#123;item.icon&#125;&#125;'&gt;&lt;/image&gt; &lt;text wx:if="&#123;&#123;item.selected&#125;&#125;" class='tabBar-selectText'&gt;&#123;&#123;item.text&#125;&#125;&lt;/text&gt; &lt;text wx:else&gt;&#123;&#123;item.text&#125;&#125;&lt;/text&gt; &lt;button id='tab&#123;&#123;index&#125;&#125;' form-type='submit' hidden='true'&gt;sub&lt;/button&gt; &lt;/label&gt; &lt;/form&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435/* home.js */Page(&#123; data: &#123; icons: icons.home, tabBar: &#123; list: [ &#123; text: '首页', icon: icons.tab.home, selected: true &#125;, &#123; text: '消息', icon: icons.tab._message, url: '../message/main/main', selected: false &#125;, &#123; text: '我的', icon: icons.tab._mine, url: '../mine/menu/menu', selected: false &#125; ] &#125; &#125;, getForm(e)&#123; let url = e.currentTarget.dataset.url //获取跳转路径 api.sendFormId(&#123; formId:e.detail.formId //获取生成的formId &#125;) wx.redirectTo(&#123; url: url &#125;) &#125;&#125;]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>表单</tag>
        <tag>formId</tag>
        <tag>模板消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序自定义按钮样式]]></title>
    <url>%2F2018%2F02%2F03%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%92%AE%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近在开发微信小程序，根据设计图完成页面。遇到如下图的设计稿，实现过程中发现微信小程序自带的按钮一直会有一条黑色边框，使用常规 CSS 无法清除，导致页面的保存按钮不能实现与设计师相同的效果。 经过查找资料成功解决，现记录下来，以防忘记。 默认按钮在解决问题之前，先来看看微信小程序默认的按钮样式。 根据官方文档说明，微信小程序的按钮可有三种不同的类型，分别时：primary（绿色）、warn（红色）和 default （灰白色）。按钮上的文字颜色根据不同类型自动变化。 不过在实际开发过程中默认的按钮样式一定无法达到设计师的要求，那么我们如何自定义样式呢？ 自定义按钮样式通过在 wxss 中为 button 设置样式可自定义按钮样式。 上图中我为最底下的按钮设置了背景颜色和字体大小。与设计稿相比可发现设计稿中没有圆角，并且没有边框。接下来为按钮设置 border-radius:0;border:0; 的样式来清除圆角和边框。 o((⊙﹏⊙))o 起初看到这个结果我以为是还有圆角（近视眼伤不起啊），后来经过放大发现是 border 的原因。但是我写了 border:0; 了呀。为什么还有，不科学。 经过一番查找，终于找到了解决方案。原来是微信小程序里覆盖border样式需要在after伪元素里设置才能生效。经实际测试有效。不明白为什么微信小程序要这样设计。]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>样式</tag>
        <tag>按钮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS浮动学习]]></title>
    <url>%2F2017%2F11%2F20%2FCSS%E6%B5%AE%E5%8A%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[常规流、包含块和块框 页面内容像流水一样从上至下，从左自动排列即为常规流。如果一个元素处于常规流则会自动将之后的元素（文本、图像等）顶到后边。 对常规流内的元素设置浮动或定位可使该元素脱离常规流（并不全是） 一个元素的包含块即该元素的块级父元素。 一个元素设置了浮动后则变为浮动元素（即块框） 浮动元素与常规流浮动元素既在常规流内又在常规流外。 浮动元素不直接影响块级元素布局（块级元素当浮动元素不存在） 浮动元素间接影响行内元素布局（可直接影响行内元素尺寸，行内元素可影响块级元素布局） 浮动与定位 浮动不可与定位同时使用 同时拥有浮动与定位的元素则浮动会失效而定位生效 相对定位不受以上规则限制（相对定位不会使元素脱离常规流） 浮动元素的摆放 拥有浮动属性的元素会尽量靠上 拥有浮动属性的元素会尽量靠向浮动的方向 若两个浮动元素为兄弟元素则在第一二条基础上可能相互靠近，margin为两者之和 浮动元素不能超出其包含块（除非浮动元素比包含块尺寸更大） 浮动元素不能超出其所在行的最高点 浮动元素不能超过其前面浮动元素的最高点 浮动元素与行内元素 行内元素可出现在左浮动元素的右边与右浮动元素的左边 左浮动元素的左边及右浮动元素的右边不能出现行内元素（共用同一包含块时） 浮动的清除(clear)clear: none | left | right |both; 浮动的清除指含有clear属性的元素下移，直到某一边（或两边）没有浮动元素为止 clear只对块级元素有效 浮动的闭合因块级元素当浮动元素不存在，所以块级元素内的元素含有浮动属性时，块级元素的高度会塌陷。（块级元素默认无高度，靠内部的行内元素撑开高度或人为设置高度） 一般情况下我们希望浮动元素本身可将其包含块的高度撑开，达到此效果则被称为浮动闭合。 闭合方法 为浮动元素的包含块设置高度（暴力） 在浮动元素的包含块内放置行内元素，并将该行内元素设置为100% 为浮动元素的包含块设置overflow:hidden;（BFC） 在浮动元素的包含块内放置一个常规流内的块级元素（一般使用::after将其设置为块级元素，块级元素的宽度默认为100%），利用clear将元素下移的能力将包含块撑开 display:flow-root]]></content>
      <tags>
        <tag>css</tag>
        <tag>浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用javascript撸一棵二叉排序树]]></title>
    <url>%2F2017%2F10%2F09%2Fjavascript%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[什么是二叉排序树二叉排序树是一棵空树或者是具有下列性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； 左、右子树也分别为二叉排序树 构造二叉排序树创建节点（Node) 类1234567class Node&#123; constructor(key)&#123; this.left = null //左子树 this.right = null //右子树 this.key = key //节点的值 &#125;&#125; 创建树（Tree）类 因ES6中没有私有方法的定义方式，这里使用《ECMAScript 6 入门》中推荐的Symbol方式定义Tree类的私有方法。 1234567891011const insertNode = Symbol('insertNode'), orderTraversal = Symbol('orderTraversal'), preorderTraversal = Symbol('preorderTraversal'), posteriorTraversal = Symbol('posteriorTraversal'), search = Symbol('search')class Tree &#123; constructor() &#123; this.root = null //树根默认为空 &#125;&#125; Tree 的公有方法获取整棵树123getTree() &#123; return this.root&#125; 在树中插入节点在树中插入节点时，先生成一个新的节点，然后判断树的根节点是否为空；如果树的根节点为空，则将树的根节点设为新生成的节点，否则调用私有的 insertNode 方法为树添加节点。 12345678insert(key) &#123; let node = new Node(key) if (this.root === null) &#123; this.root = node &#125; else &#123; this[insertNode](this.root, node) &#125;&#125; 在树中搜索节点123search(key)&#123; this[search](this.root,key)&#125; 遍历整棵树从树的根节点开始遍历整棵树。 1234567891011121314/*先序遍历*/preorderTraversal()&#123; this[preorderTraversal](this.root) //调用私有方法&#125;/*中序遍历*/orderTraversal()&#123; this[orderTraversal](this.root) //调用私有方法&#125;/*后序遍历*/posteriorTraversal()&#123; this[posteriorTraversal](this.root) //调用私有方法&#125; 毁掉这棵树123destory()&#123; this.root = null&#125; Tree 的私有方法插入节点insertNode 方法接收两个参数，第一个参数为当前节点（从树的根节点开始），第二个参数为新生成的节点；插入节点时，首先比较当前节点的值与新节点的值的大小。 如果新节点的值小于或等于当前节点的值，则判断当前节点的左孩子是否为空；如果新节点的值大于当前节点的值，则判断当前节点的右孩子是否为空；如果当前节点的左（右）孩子为空，则将当前节点的左（右）孩子设置成新节点，否则将当前节点的左（右）孩子作为 insertNode 方法的第一个参数，继续使用新生成的节点作为第二个参数进行递归。 1234567891011121314151617[insertNode](node, newNode) &#123; if (newNode.key &lt;= node.key) &#123; // 判断新节点的值是否小于当前节点的值 if (node.left === null) &#123; // 判断当前节点有没有左孩子 node.left = newNode &#125; else &#123; // 在当前节点有左孩子时，以当前节点的左孩子作为起点再次进行递归 this[insertNode](node.left, newNode) &#125; &#125; else &#123; if (node.right === null) &#123; // 判断当前节点有没有右孩子 node.right = newNode &#125; else &#123; // 在当前节点有左孩子时，以当前节点的右孩子作为起点再次进行递归 this[insertNode](node.right, newNode) &#125; &#125;&#125; 在树中搜索节点该方法接受两个参数，第一个为当前节点，第二个为要查询的值。 首先查询当前节点是否存在，如果当前节点不存在则代表没有找到结果。然后比较当前节点的值与需要查询的值进行比较，如果要查询的值小于（大于）当前节点的值，则将当前节点的左（右）孩子作为 search 方法的第一个参数，继续使用要查询的值作为第二个参数进行递归。如果当前节点的值与要查询的值相同则输出当前节点与当前节点的值。12345678910111213[search](node,key)&#123; if(node)&#123; if (key &lt; node.key) &#123; // 判断搜索的值是否小于当前节点的值 this[search](node.left, key) // 从当前节点的左孩子开始，再次递归搜索 &#125; else if (key &gt; node.key) &#123; // 判断搜索的值是否大于当前节点的值 this[search](node.right, key) // 从当前节点的右孩子开始，再次递归搜索 &#125; else if (key === node.key) &#123; console.log(node, node.key) // 如果当前节点的值等于要搜索的值则表示搜索成功 &#125; &#125;else&#123; console.log('not found') &#125;&#125; 遍历整棵树从树的根节点开始，对树的所有节点进行递归。 1234567891011121314151617181920212223242526/*先序遍历*/[preorderTraversal](node)&#123; if(node)&#123; console.log(node.key) // 输出当前节点的值 this[preorderTraversal](node.left) // 对当前节点的左子树进行递归 this[preorderTraversal](node.right) // 对当前节点的右子树进行递归 &#125;&#125;/*中序遍历*/[orderTraversal](node)&#123; if(node)&#123; this[orderTraversal](node.left) // 对当前节点的左子树进行递归 console.log(node.key) // 输出当前节点的值 this[orderTraversal](node.right) // 对当前节点的右子树进行递归 &#125;&#125;/*后序遍历*/[posteriorTraversal](node)&#123; if(node)&#123; this[posteriorTraversal](node.left) // 对当前节点的左子树进行递归 this[posteriorTraversal](node.right) // 对当前节点的右子树进行递归 console.log(node.key) // 输出当前节点的值 &#125;&#125; 实例化一棵树12345let arr = [8, 4, 9, 7, 10, 50, 3, 60,100]let tree = new Tree()arr.forEach(function(num) &#123; tree.insert(num) // 将数组中的元素添加到树上&#125;) 下载源文件： https://share.weiyun.com/53b4a1f34c104f7d76a91c93e1d25e44]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>数据结构</tag>
        <tag>二叉排序树</tag>
      </tags>
  </entry>
</search>
