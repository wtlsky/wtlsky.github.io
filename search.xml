<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用javascript撸一棵二叉排序树]]></title>
    <url>%2F2017%2F10%2F09%2Fjavascript%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[什么是二叉排序树二叉排序树是一棵空树或者是具有下列性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； 左、右子树也分别为二叉排序树 构造二叉排序树创建节点（Node) 类1234567class Node&#123; constructor(key)&#123; this.left = null //左子树 this.right = null //右子树 this.key = key //节点的值 &#125;&#125; 创建树（Tree）类 因ES6中没有私有方法的定义方式，这里使用《ECMAScript 6 入门》中推荐的Symbol方式定义Tree类的私有方法。 1234567891011const insertNode = Symbol('insertNode'), orderTraversal = Symbol('orderTraversal'), preorderTraversal = Symbol('preorderTraversal'), posteriorTraversal = Symbol('posteriorTraversal'), search = Symbol('search')class Tree &#123; constructor() &#123; this.root = null //树根默认为空 &#125;&#125; Tree 的公有方法获取整棵树123getTree() &#123; return this.root&#125; 在树中插入节点在树中插入节点时，先生成一个新的节点，然后判断树的根节点是否为空；如果树的根节点为空，则将树的根节点设为新生成的节点，否则调用私有的 insertNode 方法为树添加节点。 12345678insert(key) &#123; let node = new Node(key) if (this.root === null) &#123; this.root = node &#125; else &#123; this[insertNode](this.root, node) &#125;&#125; 在树中搜索节点123search(key)&#123; this[search](this.root,key)&#125; 遍历整棵树从树的根节点开始遍历整棵树。 1234567891011121314/*先序遍历*/preorderTraversal()&#123; this[preorderTraversal](this.root) //调用私有方法&#125;/*中序遍历*/orderTraversal()&#123; this[orderTraversal](this.root) //调用私有方法&#125;/*后序遍历*/posteriorTraversal()&#123; this[posteriorTraversal](this.root) //调用私有方法&#125; 毁掉这棵树123destory()&#123; this.root = null&#125; Tree 的私有方法插入节点insertNode 方法接收两个参数，第一个参数为当前节点（从树的根节点开始），第二个参数为新生成的节点；插入节点时，首先比较当前节点的值与新节点的值的大小。 如果新节点的值小于或等于当前节点的值，则判断当前节点的左孩子是否为空；如果新节点的值大于当前节点的值，则判断当前节点的右孩子是否为空；如果当前节点的左（右）孩子为空，则将当前节点的左（右）孩子设置成新节点，否则将当前节点的左（右）孩子作为 insertNode 方法的第一个参数，继续使用新生成的节点作为第二个参数进行递归。 1234567891011121314151617[insertNode](node, newNode) &#123; if (newNode.key &lt;= node.key) &#123; // 判断新节点的值是否小于当前节点的值 if (node.left === null) &#123; // 判断当前节点有没有左孩子 node.left = newNode &#125; else &#123; // 在当前节点有左孩子时，以当前节点的左孩子作为起点再次进行递归 this[insertNode](node.left, newNode) &#125; &#125; else &#123; if (node.right === null) &#123; // 判断当前节点有没有右孩子 node.right = newNode &#125; else &#123; // 在当前节点有左孩子时，以当前节点的右孩子作为起点再次进行递归 this[insertNode](node.right, newNode) &#125; &#125;&#125; 在树中搜索节点该方法接受两个参数，第一个为当前节点，第二个为要查询的值。 首先查询当前节点是否存在，如果当前节点不存在则代表没有找到结果。然后比较当前节点的值与需要查询的值进行比较，如果要查询的值小于（大于）当前节点的值，则将当前节点的左（右）孩子作为 search 方法的第一个参数，继续使用要查询的值作为第二个参数进行递归。如果当前节点的值与要查询的值相同则输出当前节点与当前节点的值。12345678910111213[search](node,key)&#123; if(node)&#123; if (key &lt; node.key) &#123; // 判断搜索的值是否小于当前节点的值 this[search](node.left, key) // 从当前节点的左孩子开始，再次递归搜索 &#125; else if (key &gt; node.key) &#123; // 判断搜索的值是否大于当前节点的值 this[search](node.right, key) // 从当前节点的右孩子开始，再次递归搜索 &#125; else if (key === node.key) &#123; console.log(node, node.key) // 如果当前节点的值等于要搜索的值则表示搜索成功 &#125; &#125;else&#123; console.log('not found') &#125;&#125; 遍历整棵树从树的根节点开始，对树的所有节点进行递归。 1234567891011121314151617181920212223242526/*先序遍历*/[preorderTraversal](node)&#123; if(node)&#123; console.log(node.key) // 输出当前节点的值 this[preorderTraversal](node.left) // 对当前节点的左子树进行递归 this[preorderTraversal](node.right) // 对当前节点的右子树进行递归 &#125;&#125;/*中序遍历*/[orderTraversal](node)&#123; if(node)&#123; this[orderTraversal](node.left) // 对当前节点的左子树进行递归 console.log(node.key) // 输出当前节点的值 this[orderTraversal](node.right) // 对当前节点的右子树进行递归 &#125;&#125;/*后序遍历*/[posteriorTraversal](node)&#123; if(node)&#123; this[posteriorTraversal](node.left) // 对当前节点的左子树进行递归 this[posteriorTraversal](node.right) // 对当前节点的右子树进行递归 console.log(node.key) // 输出当前节点的值 &#125;&#125; 实例化一棵树12345let arr = [8, 4, 9, 7, 10, 50, 3, 60,100]let tree = new Tree()arr.forEach(function(num) &#123; tree.insert(num) // 将数组中的元素添加到树上&#125;) 下载源文件： https://share.weiyun.com/53b4a1f34c104f7d76a91c93e1d25e44]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>数据结构</tag>
        <tag>二叉排序树</tag>
      </tags>
  </entry>
</search>
