<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TianLiang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wtlsky.github.io/"/>
  <updated>2018-05-06T10:33:16.145Z</updated>
  <id>https://wtlsky.github.io/</id>
  
  <author>
    <name>武天亮</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序文件保存踩坑记</title>
    <link href="https://wtlsky.github.io/2018/05/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>https://wtlsky.github.io/2018/05/06/微信小程序文件保存踩坑记/</id>
    <published>2018-05-06T08:20:00.000Z</published>
    <updated>2018-05-06T10:33:16.145Z</updated>
    
    <content type="html"><![CDATA[<p>在同事近期开发的项目中遇到一个需求：将小程序中的视频保存在用户手机相册中。所以前往官方文档查询实现方法。发现官方提供了  <code>wx.downloadFile</code> 和 <code>wx.saveFile</code>  接口，遂告诉同事使用这两个接口进行保存，然而在手机相册中并未找到下载的文件。后仔细阅读文档后发现了 <code>wx.saveVideoToPhotosAlbum</code>  这个接口才得以解决问题。事后认真阅读文档整理了这篇踩坑记录。<br><a id="more"></a></p><h1 id="车祸现场"><a href="#车祸现场" class="headerlink" title="车祸现场"></a>车祸现场</h1><h2 id="现场还原"><a href="#现场还原" class="headerlink" title="现场还原"></a>现场还原</h2><p>初次尝试时直接使用 <code>wx.downloadFile</code> 和 <code>wx.saveFile</code> 接口进行文件保存，并没有按照预期实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这是错误的示范</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    videoUrl: <span class="string">'http://zhidingfun.test.qingcdn.com/wykl5.mp4'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    <span class="keyword">let</span> task = wx.downloadFile(&#123;</span><br><span class="line">      url: <span class="keyword">this</span>.data.videoUrl,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        wx.saveFile(&#123;</span><br><span class="line">          tempFilePath: res.tempFilePath,</span><br><span class="line">          success(fileRes)&#123;</span><br><span class="line">              ...</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    task.onProgressUpdate(<span class="function"><span class="params">res</span> =&gt;</span> &#123;    </span><br><span class="line">      <span class="built_in">console</span>.log(res.progress)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>没有按照预期保存成功的原因在于 <code>wx.saveFile</code> 仅仅是将文件保存在手机的某个目录中并不是保存到手机相册当中。同理，图片保存也有专门的保存方法不能简单的使用 <code>wx.saveFile</code> 解决问题。</p><h2 id="事故抢救"><a href="#事故抢救" class="headerlink" title="事故抢救"></a>事故抢救</h2><p>使用 <code>wx.saveVideoToPhotosAlbum</code> 解决问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是个正确的解法</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    videoUrl: <span class="string">'http://zhidingfun.test.qingcdn.com/wykl5.mp4'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    <span class="keyword">let</span> task = wx.downloadFile(&#123;</span><br><span class="line">      url: <span class="keyword">this</span>.data.videoUrl,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        wx.saveVideoToPhotosAlbum(&#123; <span class="comment">//注意看这里</span></span><br><span class="line">          filePath: res.tempFilePath,</span><br><span class="line">          success(fileRes)&#123;</span><br><span class="line">              ...</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    task.onProgressUpdate(<span class="function"><span class="params">res</span> =&gt;</span> &#123;    </span><br><span class="line">      <span class="built_in">console</span>.log(res.progress)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h1 id="接口解读"><a href="#接口解读" class="headerlink" title="接口解读"></a>接口解读</h1><h2 id="wx-downloadFile"><a href="#wx-downloadFile" class="headerlink" title="wx.downloadFile"></a>wx.downloadFile</h2><p><code>wx.downloadFile</code> 接口是下载文件必须的接口。这个接口下载文件资源到本地，客户端直接发起一个 HTTP GET 请求，返回文件的本地临时路径。 需要注意的是这个接口返回的临时路径只在小程序本次启动期间有效。官方文档对这个接口标注说明如需持久保存需要主动调用 <code>wx.saveFile</code> 接口，然而如果没有认真阅读文档的视频和图片部分，直接使用 <code>wx.saveFile</code> 保存视频和图片文件将无法成功在手机相册中查看。</p><p><code>wx.downloadFile</code> 接口从基础库 1.4.0 开始会返回一个 <code>downloadTask</code>  对象。通过 <code>downloadTask</code>  对象可以监听下载进度和取消下载任务。</p><p>官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/api/network-file.html#wxdownloadfileobject" target="_blank" rel="noopener">点击查看</a></p><h2 id="wx-saveFile"><a href="#wx-saveFile" class="headerlink" title="wx.saveFile"></a>wx.saveFile</h2><p><code>wx.saveFile</code> 接口可以将文件保存到本地。该接口保存的文件可使用 <code>wx.getSavedFileList</code> 查看。</p><blockquote><p>注意：</p><ol><li>该接口接受的文件地址必须是小程序生成的临时地址，不能是网络地址。</li><li>该接口会把临时地址的文件进行移动，所以调用该接口后原先的临时地址将失效。</li><li>使用该接口保存的文件总计不得超过10M。</li><li>使用该接口保存的文件仅供小程序使用，其他程序无法读取。</li><li>使用该接口保存的 doc, xls, ppt, pdf, docx, xlsx, pptx 格式的文件可使用 <code>wx.openDocument</code> 接口打开。</li></ol></blockquote><h2 id="wx-openDocument"><a href="#wx-openDocument" class="headerlink" title="wx.openDocument"></a>wx.openDocument</h2><p><code>wx.openDocument</code> 接口用来打开使用 <code>wx.saveFile</code> 保存的文件。</p><p>该接口可打开 doc, xls, ppt, pdf, docx, xlsx, pptx 格式的文件。打开以上格式的文件时推荐指定文件类型。如过打开的不是以上格式的文件则会将文件以 BinaryString 的形式返回（与 FileReader.readAsBinaryString 返回结果一致）。</p><h2 id="wx-saveImageToPhotosAlbum"><a href="#wx-saveImageToPhotosAlbum" class="headerlink" title="wx.saveImageToPhotosAlbum"></a>wx.saveImageToPhotosAlbum</h2><p><code>wx.saveImageToPhotosAlbum</code> 接口可以将图片保存到用户手机的相册中。该接口的 filePath 属性可以是临时文件路径也可以是永久文件路径，但不支持网络图片路径。也就是说该接口只能使用 <code>wx.downloadFile</code> 接口提供的临时路径和 <code>wx.saveFile</code> 提供的永久路径。</p><h2 id="wx-saveVideoToPhotosAlbum"><a href="#wx-saveVideoToPhotosAlbum" class="headerlink" title="wx.saveVideoToPhotosAlbum"></a>wx.saveVideoToPhotosAlbum</h2><p><code>wx.saveVideoToPhotosAlbum</code> 接口可以将视频保存到用户手机的相处中。该接口的 filePath 属性可以是临时文件路径也可以是永久文件路径，但不支持网络图片路径。也就是说该接口只能使用 <code>wx.downloadFile</code> 接口提供的临时路径和 <code>wx.saveFile</code> 提供的永久路径。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;docid=513c8b7a7b019ea324ca7667ca59cf71&amp;highline=%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98" target="_blank" rel="noopener">wx.saveFile 保存的文件在哪里</a></li><li><a href="https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;docid=000c8210d8c6f063db76aaeed56400&amp;highline=%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98" target="_blank" rel="noopener">微信小程序 saveFile 保存文件的大小限制 10M 是什么意思？</a></li><li><a href="https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;docid=0002e0863dcdb0df0a86fad1051000&amp;highline=%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98" target="_blank" rel="noopener">wx.saveFile 保存的文件在手机上哪个位置</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在同事近期开发的项目中遇到一个需求：将小程序中的视频保存在用户手机相册中。所以前往官方文档查询实现方法。发现官方提供了  &lt;code&gt;wx.downloadFile&lt;/code&gt; 和 &lt;code&gt;wx.saveFile&lt;/code&gt;  接口，遂告诉同事使用这两个接口进行保存，然而在手机相册中并未找到下载的文件。后仔细阅读文档后发现了 &lt;code&gt;wx.saveVideoToPhotosAlbum&lt;/code&gt;  这个接口才得以解决问题。事后认真阅读文档整理了这篇踩坑记录。&lt;br&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="https://wtlsky.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="文件保存" scheme="https://wtlsky.github.io/tags/%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98/"/>
    
      <category term="视频保存" scheme="https://wtlsky.github.io/tags/%E8%A7%86%E9%A2%91%E4%BF%9D%E5%AD%98/"/>
    
      <category term="图片保存" scheme="https://wtlsky.github.io/tags/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序无限生成 form ID</title>
    <link href="https://wtlsky.github.io/2018/02/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%A0%E9%99%90%E5%88%B6%E7%94%9F%E6%88%90formId/"/>
    <id>https://wtlsky.github.io/2018/02/28/微信小程序无限制生成formId/</id>
    <published>2018-02-28T11:58:00.000Z</published>
    <updated>2018-05-06T08:30:52.764Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p style="color:#d33332">请注意：如无特殊情况不建议使用该方法生成form ID为用户推送消息，可能会对用户造成骚扰。从用户角度出发建议明确告知用户消息推送机制，按照正常流程为用户提供消息推送服务</p></blockquote><p>微信小程序模板消息推送需要配合form ID进行使用，这种做法可以防止服务方对用户产生消息骚扰。而这种设定带来便利的同时也对服务端为用户提供更好的服务产生了阻碍。在用户提交一次表单后发送多条消息提醒的环境中，服务方无法保证拿到足够数量的form ID来为用户下发消息提醒。这时需要使用变通的方法获取足够数量的 from ID。</p><a id="more"></a><h3 id="微信小程序模板消息（官方说明）"><a href="#微信小程序模板消息（官方说明）" class="headerlink" title="微信小程序模板消息（官方说明）"></a>微信小程序模板消息（官方说明）</h3><blockquote><p>微信小程序基于微信的通知渠道，为开发者提供了可以高效触达用户的模板消息能力，以便实现服务的闭环并提供更佳的体验。</p><h4 id="下发条件说明"><a href="#下发条件说明" class="headerlink" title="下发条件说明"></a>下发条件说明</h4><ol><li>支付<br>当用户在小程序内完成过支付行为，可允许开发者向用户在 7 天内推送有限条数的模板消息（1 次支付可下发 3 条，多次支付下发条数独立，互相不影响）</li><li>提交表单<br>当用户在小程序内发生过提交<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/form.html" target="_blank" rel="noopener">表单</a>行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在 7 天内推送有限条数的模板消息（1 次提交表单可下发 1 条，多次提交下发条数独立，相互不影响）</li></ol></blockquote><h3 id="单条-form-ID-生成方法"><a href="#单条-form-ID-生成方法" class="headerlink" title="单条 form ID 生成方法"></a>单条 form ID 生成方法</h3><p>根据微信小程序官方文档说明，当用户主动提交一个<code>report-submit</code>属性为 true 的表单时，即可产生一个from ID。</p><h3 id="无限生成示例"><a href="#无限生成示例" class="headerlink" title="无限生成示例"></a>无限生成示例</h3><p>根据单条生成规则，可在用户常用按钮上包裹 form 表单并将表单的<code>report-submit</code>属性设置为 true ，这样即可在用户点击按钮时提交一个隐藏的表单来生成一个 form ID。服务端可将该 form ID 收集起来为之后的消息推送做准备。</p><p><img src="http://ow0mz7346.bkt.clouddn.com/18-3-4/89476042.jpg" alt="触发按钮"></p><p>上图为自定义的底部 tab 导航按钮，该区域为用户常用点击区域。现将该区域改造为 form ID 生成点。</p><p>使用form元素将每个按钮包裹成为一个表单。并为button元素设置<code>form-type=&quot;submit&quot;</code>来提交该表单。设置button元素为hidden，使用与之绑定的label元素美化样式即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- home.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'tabBar'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">bindsubmit</span>=<span class="string">'getForm'</span> <span class="attr">report-submit</span>=<span class="string">'true'</span> <span class="attr">data-url</span>=<span class="string">'&#123;&#123;item.url&#125;&#125;'</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;tabBar.list&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">'tab&#123;&#123;index&#125;&#125;'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">'&#123;&#123;item.icon&#125;&#125;'</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;item.selected&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">'tabBar-selectText'</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:else</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'tab&#123;&#123;index&#125;&#125;'</span> <span class="attr">form-type</span>=<span class="string">'submit'</span> <span class="attr">hidden</span>=<span class="string">'true'</span>&gt;</span>sub<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* home.js */</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    icons: icons.home,</span><br><span class="line">    tabBar: &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123;</span><br><span class="line">          text: <span class="string">'首页'</span>,</span><br><span class="line">          icon: icons.tab.home,</span><br><span class="line">          selected: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: <span class="string">'消息'</span>,</span><br><span class="line">          icon: icons.tab._message,</span><br><span class="line">          url: <span class="string">'../message/main/main'</span>,</span><br><span class="line">          selected: <span class="literal">false</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          text: <span class="string">'我的'</span>,</span><br><span class="line">          icon: icons.tab._mine,</span><br><span class="line">          url: <span class="string">'../mine/menu/menu'</span>,</span><br><span class="line">          selected: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getForm(e)&#123;</span><br><span class="line">    <span class="keyword">let</span> url = e.currentTarget.dataset.url <span class="comment">//获取跳转路径</span></span><br><span class="line">    api.sendFormId(&#123;</span><br><span class="line">      formId:e.detail.formId <span class="comment">//获取生成的formId</span></span><br><span class="line">    &#125;)</span><br><span class="line">    wx.redirectTo(&#123;</span><br><span class="line">      url: url</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p style=&quot;color:#d33332&quot;&gt;请注意：如无特殊情况不建议使用该方法生成form ID为用户推送消息，可能会对用户造成骚扰。从用户角度出发建议明确告知用户消息推送机制，按照正常流程为用户提供消息推送服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微信小程序模板消息推送需要配合form ID进行使用，这种做法可以防止服务方对用户产生消息骚扰。而这种设定带来便利的同时也对服务端为用户提供更好的服务产生了阻碍。在用户提交一次表单后发送多条消息提醒的环境中，服务方无法保证拿到足够数量的form ID来为用户下发消息提醒。这时需要使用变通的方法获取足够数量的 from ID。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="https://wtlsky.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="表单" scheme="https://wtlsky.github.io/tags/%E8%A1%A8%E5%8D%95/"/>
    
      <category term="formId" scheme="https://wtlsky.github.io/tags/formId/"/>
    
      <category term="模板消息" scheme="https://wtlsky.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序自定义按钮样式</title>
    <link href="https://wtlsky.github.io/2018/02/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%92%AE%E6%A0%B7%E5%BC%8F/"/>
    <id>https://wtlsky.github.io/2018/02/03/微信小程序自定义按钮样式/</id>
    <published>2018-02-03T11:41:00.000Z</published>
    <updated>2018-02-03T13:05:18.399Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开发微信小程序，根据设计图完成页面。遇到如下图的设计稿，实现过程中发现微信小程序自带的按钮一直会有一条黑色边框，使用常规 CSS 无法清除，导致页面的保存按钮不能实现与设计师相同的效果。</p><p>经过查找资料成功解决，现记录下来，以防忘记。</p><p><img src="http://ow0mz7346.bkt.clouddn.com/18-2-3/63721704.jpg?imageMogr2/thumbnail/!55p" alt="设计图"></p><a id="more"></a><h2 id="默认按钮"><a href="#默认按钮" class="headerlink" title="默认按钮"></a>默认按钮</h2><p>在解决问题之前，先来看看微信小程序默认的按钮样式。</p><p><img src="http://ow0mz7346.bkt.clouddn.com/18-2-3/93158409.jpg" alt="默认按钮"></p><p>根据官方文档说明，微信小程序的按钮可有三种不同的类型，分别时：<code>primary</code>（绿色）、<code>warn</code>（红色）和 <code>default</code> （灰白色）。按钮上的文字颜色根据不同类型自动变化。</p><p>不过在实际开发过程中默认的按钮样式一定无法达到设计师的要求，那么我们如何自定义样式呢？</p><h2 id="自定义按钮样式"><a href="#自定义按钮样式" class="headerlink" title="自定义按钮样式"></a>自定义按钮样式</h2><p>通过在 wxss 中为 button 设置样式可自定义按钮样式。</p><p><img src="http://ow0mz7346.bkt.clouddn.com/18-2-3/31196457.jpg?" alt="自定义按钮样式"></p><p>上图中我为最底下的按钮设置了背景颜色和字体大小。与设计稿相比可发现设计稿中没有圆角，并且没有边框。接下来为按钮设置 <code>border-radius:0;border:0;</code> 的样式来清除圆角和边框。</p><p><img src="http://ow0mz7346.bkt.clouddn.com/18-2-3/33044597.jpg" alt="清除圆角和边框-未成功"></p><p><img src="http://ow0mz7346.bkt.clouddn.com/18-2-3/82763648.jpg" alt="放大图"></p><p>o((⊙﹏⊙))o 起初看到这个结果我以为是还有圆角（近视眼伤不起啊），后来经过放大发现是 border 的原因。但是我写了    <code>border:0;</code> 了呀。为什么还有，不科学。</p><p>经过一番查找，终于找到了解决方案。原来是微信小程序里覆盖border样式需要在after伪元素里设置才能生效。经实际测试有效。不明白为什么微信小程序要这样设计。</p><p><img src="http://ow0mz7346.bkt.clouddn.com/18-2-3/29101258.jpg" alt="最终效果图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在开发微信小程序，根据设计图完成页面。遇到如下图的设计稿，实现过程中发现微信小程序自带的按钮一直会有一条黑色边框，使用常规 CSS 无法清除，导致页面的保存按钮不能实现与设计师相同的效果。&lt;/p&gt;
&lt;p&gt;经过查找资料成功解决，现记录下来，以防忘记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ow0mz7346.bkt.clouddn.com/18-2-3/63721704.jpg?imageMogr2/thumbnail/!55p&quot; alt=&quot;设计图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="https://wtlsky.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="样式" scheme="https://wtlsky.github.io/tags/%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="按钮" scheme="https://wtlsky.github.io/tags/%E6%8C%89%E9%92%AE/"/>
    
  </entry>
  
  <entry>
    <title>CSS浮动学习</title>
    <link href="https://wtlsky.github.io/2017/11/20/CSS%E6%B5%AE%E5%8A%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wtlsky.github.io/2017/11/20/CSS浮动学习/</id>
    <published>2017-11-20T12:04:32.000Z</published>
    <updated>2018-01-23T12:53:10.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常规流、包含块和块框"><a href="#常规流、包含块和块框" class="headerlink" title="常规流、包含块和块框"></a>常规流、包含块和块框</h1><ul><li><p>页面内容像流水一样从上至下，从左自动排列即为常规流。如果一个元素处于常规流则会自动将之后的元素（文本、图像等）顶到后边。</p></li><li><p>对常规流内的元素设置浮动或定位可使该元素脱离常规流（并不全是）</p></li><li><p>一个元素的包含块即该元素的块级父元素。</p></li><li><p>一个元素设置了浮动后则变为浮动元素（即块框）</p></li></ul><a id="more"></a><h1 id="浮动元素与常规流"><a href="#浮动元素与常规流" class="headerlink" title="浮动元素与常规流"></a>浮动元素与常规流</h1><p>浮动元素既在常规流内又在常规流外。</p><ul><li><p>浮动元素不直接影响块级元素布局（块级元素当浮动元素不存在）</p></li><li><p>浮动元素间接影响行内元素布局（可直接影响行内元素尺寸，行内元素可影响块级元素布局）</p></li></ul><h1 id="浮动与定位"><a href="#浮动与定位" class="headerlink" title="浮动与定位"></a>浮动与定位</h1><ul><li><p>浮动不可与定位同时使用</p></li><li><p>同时拥有浮动与定位的元素则浮动会失效而定位生效</p></li><li><p>相对定位不受以上规则限制（相对定位不会使元素脱离常规流）</p></li></ul><h1 id="浮动元素的摆放"><a href="#浮动元素的摆放" class="headerlink" title="浮动元素的摆放"></a>浮动元素的摆放</h1><ol><li><p>拥有浮动属性的元素会尽量靠上</p></li><li><p>拥有浮动属性的元素会尽量靠向浮动的方向</p></li><li><p>若两个浮动元素为兄弟元素则在第一二条基础上可能相互靠近，margin为两者之和</p></li><li><p>浮动元素不能超出其包含块（除非浮动元素比包含块尺寸更大）</p></li><li><p>浮动元素不能超出其所在行的最高点</p></li><li><p>浮动元素不能超过其前面浮动元素的最高点</p></li></ol><h1 id="浮动元素与行内元素"><a href="#浮动元素与行内元素" class="headerlink" title="浮动元素与行内元素"></a>浮动元素与行内元素</h1><ul><li><p>行内元素可出现在左浮动元素的右边与右浮动元素的左边</p></li><li><p>左浮动元素的左边及右浮动元素的右边不能出现行内元素（共用同一包含块时）</p></li></ul><h1 id="浮动的清除-clear"><a href="#浮动的清除-clear" class="headerlink" title="浮动的清除(clear)"></a>浮动的清除(clear)</h1><p><code>clear: none | left | right |both;</code></p><ul><li><p>浮动的清除指含有clear属性的元素下移，直到某一边（或两边）没有浮动元素为止</p></li><li><p>clear只对块级元素有效</p></li></ul><h1 id="浮动的闭合"><a href="#浮动的闭合" class="headerlink" title="浮动的闭合"></a>浮动的闭合</h1><p>因块级元素当浮动元素不存在，所以块级元素内的元素含有浮动属性时，块级元素的高度会塌陷。（块级元素默认无高度，靠内部的行内元素撑开高度或人为设置高度）</p><p>一般情况下我们希望浮动元素本身可将其包含块的高度撑开，达到此效果则被称为浮动闭合。</p><h2 id="闭合方法"><a href="#闭合方法" class="headerlink" title="闭合方法"></a>闭合方法</h2><ol><li><p>为浮动元素的包含块设置高度（暴力）</p></li><li><p>在浮动元素的包含块内放置行内元素，并将该行内元素设置为100%</p></li><li><p>为浮动元素的包含块设置overflow:hidden;（BFC）</p></li><li><p>在浮动元素的包含块内放置一个常规流内的块级元素（一般使用<code>::after</code>将其设置为块级元素，块级元素的宽度默认为100%），利用clear将元素下移的能力将包含块撑开</p></li><li><p><code>display:flow-root</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常规流、包含块和块框&quot;&gt;&lt;a href=&quot;#常规流、包含块和块框&quot; class=&quot;headerlink&quot; title=&quot;常规流、包含块和块框&quot;&gt;&lt;/a&gt;常规流、包含块和块框&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;页面内容像流水一样从上至下，从左自动排列即为常规流。如果一个元素处于常规流则会自动将之后的元素（文本、图像等）顶到后边。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对常规流内的元素设置浮动或定位可使该元素脱离常规流（并不全是）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个元素的包含块即该元素的块级父元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个元素设置了浮动后则变为浮动元素（即块框）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://wtlsky.github.io/tags/css/"/>
    
      <category term="浮动" scheme="https://wtlsky.github.io/tags/%E6%B5%AE%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用javascript撸一棵二叉排序树</title>
    <link href="https://wtlsky.github.io/2017/10/09/javascript%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>https://wtlsky.github.io/2017/10/09/javascript二叉排序树/</id>
    <published>2017-10-09T01:31:59.000Z</published>
    <updated>2018-01-22T14:09:59.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是二叉排序树"><a href="#什么是二叉排序树" class="headerlink" title="什么是二叉排序树"></a>什么是二叉排序树</h2><p>二叉排序树是一棵空树或者是具有下列性质的二叉树：</p><ol><li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>左、右子树也分别为二叉排序树</li></ol><h2 id="构造二叉排序树"><a href="#构造二叉排序树" class="headerlink" title="构造二叉排序树"></a>构造二叉排序树</h2><h3 id="创建节点（Node-类"><a href="#创建节点（Node-类" class="headerlink" title="创建节点（Node) 类"></a>创建节点（Node) 类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(key)&#123;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span> <span class="comment">//左子树</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span> <span class="comment">//右子树</span></span><br><span class="line">    <span class="keyword">this</span>.key = key <span class="comment">//节点的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建树（Tree）类"><a href="#创建树（Tree）类" class="headerlink" title="创建树（Tree）类"></a>创建树（Tree）类</h3><blockquote><p>因ES6中没有私有方法的定义方式，这里使用<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">《ECMAScript 6 入门》</a>中推荐的Symbol方式定义Tree类的私有方法。</p></blockquote><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertNode = <span class="built_in">Symbol</span>(<span class="string">'insertNode'</span>),</span><br><span class="line">      orderTraversal = <span class="built_in">Symbol</span>(<span class="string">'orderTraversal'</span>),</span><br><span class="line">      preorderTraversal = <span class="built_in">Symbol</span>(<span class="string">'preorderTraversal'</span>),</span><br><span class="line">      posteriorTraversal = <span class="built_in">Symbol</span>(<span class="string">'posteriorTraversal'</span>),</span><br><span class="line">      search = <span class="built_in">Symbol</span>(<span class="string">'search'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span> <span class="comment">//树根默认为空</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Tree-的公有方法"><a href="#Tree-的公有方法" class="headerlink" title="Tree 的公有方法"></a>Tree 的公有方法</h3><h4 id="获取整棵树"><a href="#获取整棵树" class="headerlink" title="获取整棵树"></a>获取整棵树</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getTree() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在树中插入节点"><a href="#在树中插入节点" class="headerlink" title="在树中插入节点"></a>在树中插入节点</h4><p>在树中插入节点时，先生成一个新的节点，然后判断树的根节点是否为空；如果树的根节点为空，则将树的根节点设为新生成的节点，否则调用私有的 insertNode 方法为树添加节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert(key) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">new</span> Node(key)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = node</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>[insertNode](<span class="keyword">this</span>.root, node)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在树中搜索节点"><a href="#在树中搜索节点" class="headerlink" title="在树中搜索节点"></a>在树中搜索节点</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search(key)&#123;</span><br><span class="line">  <span class="keyword">this</span>[search](<span class="keyword">this</span>.root,key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历整棵树"><a href="#遍历整棵树" class="headerlink" title="遍历整棵树"></a>遍历整棵树</h4><p>从树的根节点开始遍历整棵树。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*先序遍历*/</span></span><br><span class="line">preorderTraversal()&#123;</span><br><span class="line">  <span class="keyword">this</span>[preorderTraversal](<span class="keyword">this</span>.root) <span class="comment">//调用私有方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中序遍历*/</span></span><br><span class="line">orderTraversal()&#123;</span><br><span class="line">  <span class="keyword">this</span>[orderTraversal](<span class="keyword">this</span>.root) <span class="comment">//调用私有方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后序遍历*/</span></span><br><span class="line">posteriorTraversal()&#123;</span><br><span class="line">  <span class="keyword">this</span>[posteriorTraversal](<span class="keyword">this</span>.root) <span class="comment">//调用私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="毁掉这棵树"><a href="#毁掉这棵树" class="headerlink" title="毁掉这棵树"></a>毁掉这棵树</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">destory()&#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Tree-的私有方法"><a href="#Tree-的私有方法" class="headerlink" title="Tree 的私有方法"></a>Tree 的私有方法</h3><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>insertNode 方法接收两个参数，第一个参数为当前节点（从树的根节点开始），第二个参数为新生成的节点；插入节点时，首先比较当前节点的值与新节点的值的大小。</p><p>如果新节点的值小于或等于当前节点的值，则判断当前节点的左孩子是否为空；如果新节点的值大于当前节点的值，则判断当前节点的右孩子是否为空；如果当前节点的左（右）孩子为空，则将当前节点的左（右）孩子设置成新节点，否则将当前节点的左（右）孩子作为 insertNode 方法的第一个参数，继续使用新生成的节点作为第二个参数进行递归。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[insertNode](node, newNode) &#123;</span><br><span class="line">  <span class="keyword">if</span> (newNode.key &lt;= node.key) &#123; <span class="comment">// 判断新节点的值是否小于当前节点的值</span></span><br><span class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123; <span class="comment">// 判断当前节点有没有左孩子</span></span><br><span class="line">          node.left = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 在当前节点有左孩子时，以当前节点的左孩子作为起点再次进行递归</span></span><br><span class="line">          <span class="keyword">this</span>[insertNode](node.left, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123; <span class="comment">// 判断当前节点有没有右孩子</span></span><br><span class="line">          node.right = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在当前节点有左孩子时，以当前节点的右孩子作为起点再次进行递归</span></span><br><span class="line">        <span class="keyword">this</span>[insertNode](node.right, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在树中搜索节点-1"><a href="#在树中搜索节点-1" class="headerlink" title="在树中搜索节点"></a>在树中搜索节点</h4><p>该方法接受两个参数，第一个为当前节点，第二个为要查询的值。</p><p>首先查询当前节点是否存在，如果当前节点不存在则代表没有找到结果。然后比较当前节点的值与需要查询的值进行比较，如果要查询的值小于（大于）当前节点的值，则将当前节点的左（右）孩子作为 search 方法的第一个参数，继续使用要查询的值作为第二个参数进行递归。如果当前节点的值与要查询的值相同则输出当前节点与当前节点的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[search](node,key)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)&#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) &#123; <span class="comment">// 判断搜索的值是否小于当前节点的值</span></span><br><span class="line">            <span class="keyword">this</span>[search](node.left, key) <span class="comment">// 从当前节点的左孩子开始，再次递归搜索</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;  <span class="comment">// 判断搜索的值是否大于当前节点的值</span></span><br><span class="line">            <span class="keyword">this</span>[search](node.right, key) <span class="comment">// 从当前节点的右孩子开始，再次递归搜索</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === node.key) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(node, node.key) <span class="comment">// 如果当前节点的值等于要搜索的值则表示搜索成功</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'not found'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="遍历整棵树-1"><a href="#遍历整棵树-1" class="headerlink" title="遍历整棵树"></a>遍历整棵树</h4><p>从树的根节点开始，对树的所有节点进行递归。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*先序遍历*/</span></span><br><span class="line">[preorderTraversal](node)&#123;</span><br><span class="line">  <span class="keyword">if</span>(node)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.key) <span class="comment">// 输出当前节点的值</span></span><br><span class="line">    <span class="keyword">this</span>[preorderTraversal](node.left)  <span class="comment">// 对当前节点的左子树进行递归</span></span><br><span class="line">    <span class="keyword">this</span>[preorderTraversal](node.right) <span class="comment">// 对当前节点的右子树进行递归</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中序遍历*/</span></span><br><span class="line">[orderTraversal](node)&#123;</span><br><span class="line">  <span class="keyword">if</span>(node)&#123;</span><br><span class="line">    <span class="keyword">this</span>[orderTraversal](node.left) <span class="comment">// 对当前节点的左子树进行递归</span></span><br><span class="line">    <span class="built_in">console</span>.log(node.key) <span class="comment">// 输出当前节点的值</span></span><br><span class="line">    <span class="keyword">this</span>[orderTraversal](node.right) <span class="comment">// 对当前节点的右子树进行递归</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后序遍历*/</span></span><br><span class="line">[posteriorTraversal](node)&#123;</span><br><span class="line">  <span class="keyword">if</span>(node)&#123;</span><br><span class="line">    <span class="keyword">this</span>[posteriorTraversal](node.left) <span class="comment">// 对当前节点的左子树进行递归</span></span><br><span class="line">    <span class="keyword">this</span>[posteriorTraversal](node.right) <span class="comment">// 对当前节点的右子树进行递归</span></span><br><span class="line">    <span class="built_in">console</span>.log(node.key) <span class="comment">// 输出当前节点的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例化一棵树"><a href="#实例化一棵树" class="headerlink" title="实例化一棵树"></a>实例化一棵树</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">3</span>, <span class="number">60</span>,<span class="number">100</span>]</span><br><span class="line"><span class="keyword">let</span> tree = <span class="keyword">new</span> Tree()</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  tree.insert(num) <span class="comment">// 将数组中的元素添加到树上</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>下载源文件： <a href="https://share.weiyun.com/53b4a1f34c104f7d76a91c93e1d25e44" target="_blank" rel="noopener">https://share.weiyun.com/53b4a1f34c104f7d76a91c93e1d25e44</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是二叉排序树&quot;&gt;&lt;a href=&quot;#什么是二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;什么是二叉排序树&quot;&gt;&lt;/a&gt;什么是二叉排序树&lt;/h2&gt;&lt;p&gt;二叉排序树是一棵空树或者是具有下列性质的二叉树：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；&lt;/li&gt;
&lt;li&gt;若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；&lt;/li&gt;
&lt;li&gt;左、右子树也分别为二叉排序树&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;构造二叉排序树&quot;&gt;&lt;a href=&quot;#构造二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;构造二叉排序树&quot;&gt;&lt;/a&gt;构造二叉排序树&lt;/h2&gt;&lt;h3 id=&quot;创建节点（Node-类&quot;&gt;&lt;a href=&quot;#创建节点（Node-类&quot; class=&quot;headerlink&quot; title=&quot;创建节点（Node) 类&quot;&gt;&lt;/a&gt;创建节点（Node) 类&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(key)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.left = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//左子树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.right = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//右子树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.key = key &lt;span class=&quot;comment&quot;&gt;//节点的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;创建树（Tree）类&quot;&gt;&lt;a href=&quot;#创建树（Tree）类&quot; class=&quot;headerlink&quot; title=&quot;创建树（Tree）类&quot;&gt;&lt;/a&gt;创建树（Tree）类&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;因ES6中没有私有方法的定义方式，这里使用&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《ECMAScript 6 入门》&lt;/a&gt;中推荐的Symbol方式定义Tree类的私有方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://wtlsky.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="https://wtlsky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉排序树" scheme="https://wtlsky.github.io/tags/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    
  </entry>
  
</feed>
