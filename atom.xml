<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TianLiang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wtlsky.github.io/"/>
  <updated>2017-10-19T02:33:30.810Z</updated>
  <id>https://wtlsky.github.io/</id>
  
  <author>
    <name>武天亮</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用javascript撸一棵二叉排序树</title>
    <link href="https://wtlsky.github.io/2017/10/09/javascript%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>https://wtlsky.github.io/2017/10/09/javascript二叉排序树/</id>
    <published>2017-10-09T01:31:59.000Z</published>
    <updated>2017-10-19T02:33:30.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是二叉排序树"><a href="#什么是二叉排序树" class="headerlink" title="什么是二叉排序树"></a>什么是二叉排序树</h2><p>二叉排序树是一棵空树或者是具有下列性质的二叉树：</p><ol><li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>左、右子树也分别为二叉排序树</li></ol><h2 id="构造二叉排序树"><a href="#构造二叉排序树" class="headerlink" title="构造二叉排序树"></a>构造二叉排序树</h2><h3 id="创建节点（Node-类"><a href="#创建节点（Node-类" class="headerlink" title="创建节点（Node) 类"></a>创建节点（Node) 类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(key)&#123;</div><div class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span> <span class="comment">//左子树</span></div><div class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span> <span class="comment">//右子树</span></div><div class="line">    <span class="keyword">this</span>.key = key <span class="comment">//节点的值</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="创建树（Tree）类"><a href="#创建树（Tree）类" class="headerlink" title="创建树（Tree）类"></a>创建树（Tree）类</h3><blockquote><p>因ES6中没有私有方法的定义方式，这里使用<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external">《ECMAScript 6 入门》</a>中推荐的Symbol方式定义Tree类的私有方法。</p></blockquote><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> insertNode = <span class="built_in">Symbol</span>(<span class="string">'insertNode'</span>),</div><div class="line">      orderTraversal = <span class="built_in">Symbol</span>(<span class="string">'orderTraversal'</span>),</div><div class="line">      preorderTraversal = <span class="built_in">Symbol</span>(<span class="string">'preorderTraversal'</span>),</div><div class="line">      posteriorTraversal = <span class="built_in">Symbol</span>(<span class="string">'posteriorTraversal'</span>),</div><div class="line">      search = <span class="built_in">Symbol</span>(<span class="string">'search'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span> <span class="comment">//树根默认为空</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="Tree-的公有方法"><a href="#Tree-的公有方法" class="headerlink" title="Tree 的公有方法"></a>Tree 的公有方法</h3><h4 id="获取整棵树"><a href="#获取整棵树" class="headerlink" title="获取整棵树"></a>获取整棵树</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getTree() &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.root</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="在树中插入节点"><a href="#在树中插入节点" class="headerlink" title="在树中插入节点"></a>在树中插入节点</h4><p>在树中插入节点时，先生成一个新的节点，然后判断树的根节点是否为空；如果树的根节点为空，则将树的根节点设为新生成的节点，否则调用私有的 insertNode 方法为树添加节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">insert(key) &#123;</div><div class="line">  <span class="keyword">let</span> node = <span class="keyword">new</span> Node(key)</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.root = node</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>[insertNode](<span class="keyword">this</span>.root, node)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="在树中搜索节点"><a href="#在树中搜索节点" class="headerlink" title="在树中搜索节点"></a>在树中搜索节点</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">search(key)&#123;</div><div class="line">  <span class="keyword">this</span>[search](<span class="keyword">this</span>.root,key)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="遍历整棵树"><a href="#遍历整棵树" class="headerlink" title="遍历整棵树"></a>遍历整棵树</h4><p>从树的根节点开始遍历整棵树。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*先序遍历*/</span></div><div class="line">preorderTraversal()&#123;</div><div class="line">  <span class="keyword">this</span>[preorderTraversal](<span class="keyword">this</span>.root) <span class="comment">//调用私有方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*中序遍历*/</span></div><div class="line">orderTraversal()&#123;</div><div class="line">  <span class="keyword">this</span>[orderTraversal](<span class="keyword">this</span>.root) <span class="comment">//调用私有方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*后序遍历*/</span></div><div class="line">posteriorTraversal()&#123;</div><div class="line">  <span class="keyword">this</span>[posteriorTraversal](<span class="keyword">this</span>.root) <span class="comment">//调用私有方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="毁掉这棵树"><a href="#毁掉这棵树" class="headerlink" title="毁掉这棵树"></a>毁掉这棵树</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">destory()&#123;</div><div class="line">  <span class="keyword">this</span>.root = <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="Tree-的私有方法"><a href="#Tree-的私有方法" class="headerlink" title="Tree 的私有方法"></a>Tree 的私有方法</h3><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>insertNode 方法接收两个参数，第一个参数为当前节点（从树的根节点开始），第二个参数为新生成的节点；插入节点时，首先比较当前节点的值与新节点的值的大小。</p><p>如果新节点的值小于或等于当前节点的值，则判断当前节点的左孩子是否为空；如果新节点的值大于当前节点的值，则判断当前节点的右孩子是否为空；如果当前节点的左（右）孩子为空，则将当前节点的左（右）孩子设置成新节点，否则将当前节点的左（右）孩子作为 insertNode 方法的第一个参数，继续使用新生成的节点作为第二个参数进行递归。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[insertNode](node, newNode) &#123;</div><div class="line">  <span class="keyword">if</span> (newNode.key &lt;= node.key) &#123; <span class="comment">// 判断新节点的值是否小于当前节点的值</span></div><div class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123; <span class="comment">// 判断当前节点有没有左孩子</span></div><div class="line">          node.left = newNode</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 在当前节点有左孩子时，以当前节点的左孩子作为起点再次进行递归</span></div><div class="line">          <span class="keyword">this</span>[insertNode](node.left, newNode)</div><div class="line">      &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123; <span class="comment">// 判断当前节点有没有右孩子</span></div><div class="line">          node.right = newNode</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 在当前节点有左孩子时，以当前节点的右孩子作为起点再次进行递归</span></div><div class="line">        <span class="keyword">this</span>[insertNode](node.right, newNode)</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="在树中搜索节点-1"><a href="#在树中搜索节点-1" class="headerlink" title="在树中搜索节点"></a>在树中搜索节点</h4><p>该方法接受两个参数，第一个为当前节点，第二个为要查询的值。</p><p>首先查询当前节点是否存在，如果当前节点不存在则代表没有找到结果。然后比较当前节点的值与需要查询的值进行比较，如果要查询的值小于（大于）当前节点的值，则将当前节点的左（右）孩子作为 search 方法的第一个参数，继续使用要查询的值作为第二个参数进行递归。如果当前节点的值与要查询的值相同则输出当前节点与当前节点的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[search](node,key)&#123;</div><div class="line">    <span class="keyword">if</span>(node)&#123;</div><div class="line">        <span class="keyword">if</span> (key &lt; node.key) &#123; <span class="comment">// 判断搜索的值是否小于当前节点的值</span></div><div class="line">            <span class="keyword">this</span>[search](node.left, key) <span class="comment">// 从当前节点的左孩子开始，再次递归搜索</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;  <span class="comment">// 判断搜索的值是否大于当前节点的值</span></div><div class="line">            <span class="keyword">this</span>[search](node.right, key) <span class="comment">// 从当前节点的右孩子开始，再次递归搜索</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === node.key) &#123;</div><div class="line">            <span class="built_in">console</span>.log(node, node.key) <span class="comment">// 如果当前节点的值等于要搜索的值则表示搜索成功</span></div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'not found'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="遍历整棵树-1"><a href="#遍历整棵树-1" class="headerlink" title="遍历整棵树"></a>遍历整棵树</h4><p>从树的根节点开始，对树的所有节点进行递归。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*先序遍历*/</span></div><div class="line">[preorderTraversal](node)&#123;</div><div class="line">  <span class="keyword">if</span>(node)&#123;</div><div class="line">    <span class="built_in">console</span>.log(node.key) <span class="comment">// 输出当前节点的值</span></div><div class="line">    <span class="keyword">this</span>[preorderTraversal](node.left)  <span class="comment">// 对当前节点的左子树进行递归</span></div><div class="line">    <span class="keyword">this</span>[preorderTraversal](node.right) <span class="comment">// 对当前节点的右子树进行递归</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*中序遍历*/</span></div><div class="line">[orderTraversal](node)&#123;</div><div class="line">  <span class="keyword">if</span>(node)&#123;</div><div class="line">    <span class="keyword">this</span>[orderTraversal](node.left) <span class="comment">// 对当前节点的左子树进行递归</span></div><div class="line">    <span class="built_in">console</span>.log(node.key) <span class="comment">// 输出当前节点的值</span></div><div class="line">    <span class="keyword">this</span>[orderTraversal](node.right) <span class="comment">// 对当前节点的右子树进行递归</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*后序遍历*/</span></div><div class="line">[posteriorTraversal](node)&#123;</div><div class="line">  <span class="keyword">if</span>(node)&#123;</div><div class="line">    <span class="keyword">this</span>[posteriorTraversal](node.left) <span class="comment">// 对当前节点的左子树进行递归</span></div><div class="line">    <span class="keyword">this</span>[posteriorTraversal](node.right) <span class="comment">// 对当前节点的右子树进行递归</span></div><div class="line">    <span class="built_in">console</span>.log(node.key) <span class="comment">// 输出当前节点的值</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="实例化一棵树"><a href="#实例化一棵树" class="headerlink" title="实例化一棵树"></a>实例化一棵树</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">3</span>, <span class="number">60</span>,<span class="number">100</span>]</div><div class="line"><span class="keyword">let</span> tree = <span class="keyword">new</span> Tree()</div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  tree.insert(num) <span class="comment">// 将数组中的元素添加到树上</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><blockquote><p>下载源文件： <a href="https://share.weiyun.com/53b4a1f34c104f7d76a91c93e1d25e44" target="_blank" rel="external">https://share.weiyun.com/53b4a1f34c104f7d76a91c93e1d25e44</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是二叉排序树&quot;&gt;&lt;a href=&quot;#什么是二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;什么是二叉排序树&quot;&gt;&lt;/a&gt;什么是二叉排序树&lt;/h2&gt;&lt;p&gt;二叉排序树是一棵空树或者是具有下列性质的二叉树：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；&lt;/li&gt;
&lt;li&gt;若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；&lt;/li&gt;
&lt;li&gt;左、右子树也分别为二叉排序树&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;构造二叉排序树&quot;&gt;&lt;a href=&quot;#构造二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;构造二叉排序树&quot;&gt;&lt;/a&gt;构造二叉排序树&lt;/h2&gt;&lt;h3 id=&quot;创建节点（Node-类&quot;&gt;&lt;a href=&quot;#创建节点（Node-类&quot; class=&quot;headerlink&quot; title=&quot;创建节点（Node) 类&quot;&gt;&lt;/a&gt;创建节点（Node) 类&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(key)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.left = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//左子树&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.right = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//右子树&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.key = key &lt;span class=&quot;comment&quot;&gt;//节点的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;创建树（Tree）类&quot;&gt;&lt;a href=&quot;#创建树（Tree）类&quot; class=&quot;headerlink&quot; title=&quot;创建树（Tree）类&quot;&gt;&lt;/a&gt;创建树（Tree）类&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;因ES6中没有私有方法的定义方式，这里使用&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《ECMAScript 6 入门》&lt;/a&gt;中推荐的Symbol方式定义Tree类的私有方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://wtlsky.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="https://wtlsky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉排序树" scheme="https://wtlsky.github.io/tags/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    
  </entry>
  
</feed>
